<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Tynn by frodsan</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Tynn</h1>
      <h2 class="project-tagline">A thin library for web development in Ruby</h2>
      <a href="https://github.com/frodsan/tynn" class="btn">View on GitHub</a>
      <a href="https://github.com/frodsan/tynn/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/frodsan/tynn/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="tynn" class="anchor" href="#tynn" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Tynn</h1>

<p>A thin library for web development in Ruby.</p>

<ul>
<li><a href="#installation">Installation</a></li>
<li>
<a href="#getting-started">Getting Started</a>

<ul>
<li><a href="#hello-world">Hello World!</a></li>
<li><a href="#capturing-path-segments-and-the-inbox">Capturing Path Segments and the Inbox</a></li>
<li><a href="#handling-request-and-response">Handling Request and Response</a></li>
<li><a href="#composing-applications">Composing Applications</a></li>
<li><a href="#extending-tynn">Extending Tynn</a></li>
</ul>
</li>
<li>
<a href="#routing-basics">Routing Basics</a>

<ul>
<li><a href="#halting">Halting</a></li>
</ul>
</li>
<li><a href="#middleware">Middleware</a></li>
<li><a href="#plugins">Plugins</a></li>
<li><a href="#settings">Settings</a></li>
<li><a href="#default-plugins">Default Plugins</a></li>
<li><a href="#environments">Environments</a></li>
<li><a href="#method-override">Method Override</a></li>
<li><a href="#static-files">Static Files</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="http://api.tynn.xyz/2.0.0">API Reference</a></li>
<li><a href="#changelog">Changelog</a></li>
<li><a href="#development">Development</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#code-status">Code Status</a></li>
<li><a href="#license">License</a></li>
</ul>

<p><strong>NOTE: Tynn 2 is in an alpha phase. Anything can change at any time. Usage is not recommended until a stable version gets released.</strong></p>

<h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installation</h2>

<pre><code>$ gem install tynn
</code></pre>

<h2>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting Started</h2>

<p>In this tutorial we will assume that you have basic knowledge about HTTP and Ruby. You will learn about Rack, Tynn and cURL along the way. To code along all you need to do is <code>gem install tynn</code> and then create a folder that should contain your first app.</p>

<h3>
<a id="hello-world" class="anchor" href="#hello-world" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hello World!</h3>

<p>Tynn is a routing library that sits on top of Rack. So in order to get your first Tynn app running, we need to write a <code>config.ru</code> file. This file is used by Rack to find an application and run it. The most basic version of <code>config.ru</code> file looks like this:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-c1">File</span>.expand_path(<span class="pl-s"><span class="pl-pds">"</span>app<span class="pl-pds">"</span></span>, __dir__)

run(<span class="pl-c1">Tynn</span>)</pre></div>

<p>This will require the <code>app.rb</code> file in the current directory and then run the Rack application that is contained in it. So let's write the <code>app.rb</code> file:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">"</span>tynn<span class="pl-pds">"</span></span>

<span class="pl-c1">Tynn</span>.define <span class="pl-k">do</span>
  res.write(<span class="pl-s"><span class="pl-pds">"</span>Hello World!<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span></pre></div>

<p>In this file we first require the Tynn library, then we define our application. It will write "Hello World" to something called <code>res</code>. In Tynn, <code>res</code> is the result of the request. So in other words: Our application will answer with <code>"Hello World"</code>.</p>

<p>To run this application now, we will use a commandline tool called <code>rackup</code>. It is included in the Rack gem, so you already have it installed. You run it like this:</p>

<pre><code>rackup
</code></pre>

<p>It will then boot up and tell you something like this:</p>

<pre><code>[2015-11-30 17:27:37] INFO  WEBrick 1.3.1
[2015-11-30 17:27:37] INFO  ruby 2.2.2 (2015-04-13) [x86_64-linux]
[2015-11-30 17:27:37] INFO  WEBrick::HTTPServer#start: pid=25355 port=9292
</code></pre>

<p>This means that we are using <a href="http://ruby-doc.org/stdlib-2.2.3/libdoc/webrick/rdoc/index.html">WEBrick</a> from the Ruby standard library as our web server, and we are using the port 9292. So now you can either type <code>localhost:9292</code> in your browser of choice or use curl. curl is probably installed on your system already. If it is not, you can find information on how to install it <a href="http://curl.haxx.se/docs/install.html">here</a>. In a second terminal (while your server keeps running in the first one), type:</p>

<pre><code>curl localhost:9292
</code></pre>

<p>The result will be:</p>

<pre><code>Hello World!
</code></pre>

<p>Congratulations, you now have your first working Tynn app! But wait, on what path does it listen? As we've seen above, it definitely listens on the root path. But what about the other paths? Let's try it out with <code>curl localhost:9292/somepath</code> – and you will see the same result! Our app listens on all paths. Let's change that to only responding to the root path:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.define <span class="pl-k">do</span>
  root <span class="pl-k">do</span>
    res.write(<span class="pl-s"><span class="pl-pds">"</span>Hello World!<span class="pl-pds">"</span></span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Now <code>curl localhost:9292</code> will still return the greeting, but <code>curl localhost:9292/somepath</code> will return an empty response. As the request was not matched, it will also return a 404 status code which means "not found" in HTTP speak. You can check that with curl using the <code>-i</code> option: <code>curl -i localhost:9292/somepath</code>. If you want to learn more about status codes, check out the <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">Wikipedia page</a>.</p>

<p>Ok, so now you know how to react to the root path only. Let's continue with checking for the HTTP method. If you are not familiar with HTTP methods, check out <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods">this Wikipedia page</a>. By default, curl does a GET request. Let us try a POST request instead: <code>curl -d "" localhost:9292</code> (the <code>""</code> is just an empty body for the post request). The result is the same as for the GET request. How can we restrict it to only react to GET requests?</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.define <span class="pl-k">do</span>
  root <span class="pl-k">do</span>
    get <span class="pl-k">do</span>
      res.write(<span class="pl-s"><span class="pl-pds">"</span>Hello World!<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Now you might want to match to another path than the root path as well, so let's try this:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.define <span class="pl-k">do</span>
  root <span class="pl-k">do</span>
    get <span class="pl-k">do</span>
      res.write(<span class="pl-s"><span class="pl-pds">"</span>Hello World!<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>

  on(<span class="pl-s"><span class="pl-pds">"</span>tynn<span class="pl-pds">"</span></span>) <span class="pl-k">do</span>
    get <span class="pl-k">do</span>
      res.write(<span class="pl-s"><span class="pl-pds">"</span>Hello Tynn!<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Now we will get <code>Hello World</code> when we GET the root path, <code>Hello Tynn</code> when we GET the Tynn path and a 404 when we do anything else. Now one more thing about <code>on</code>: It is very flexible. You can either give it a single segment of the path (like above) or give it an entire path (like <code>on('a/pretty/long/path')</code>). You can also nest it, and this is what makes it really flexible:</p>

<div class="highlight highlight-source-ruby"><pre>on(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) <span class="pl-k">do</span>
  on(<span class="pl-s"><span class="pl-pds">"</span>tynn<span class="pl-pds">"</span></span>) <span class="pl-k">do</span>
    get <span class="pl-k">do</span>
      res.write(<span class="pl-s"><span class="pl-pds">"</span>Hello Tynn!<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Now you know the basics of Tynn – but there is still more to learn. Keep exploring this page!</p>

<h3>
<a id="capturing-path-segments-and-the-inbox" class="anchor" href="#capturing-path-segments-and-the-inbox" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Capturing Path Segments and the Inbox</h3>

<p>We now know how to handle static URLs and different request methods. But what about dynamic parts in the request, like an ID or the name of a blog post? Tynn has you covered:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.define <span class="pl-k">do</span>
  on(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) <span class="pl-k">do</span>
    on(<span class="pl-c1">:name</span>) <span class="pl-k">do</span>
      get <span class="pl-k">do</span>
        res.write(<span class="pl-s"><span class="pl-pds">"</span>Hello Tynn!<span class="pl-pds">"</span></span>)
      <span class="pl-k">end</span>
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>This will work for all URLs that have <code>hello</code> as their first segment and some other string as the second segment. For example <code>/hello/tynn</code> or <code>/hello/world</code>. Notice however that it will not match <code>/hello/beautiful/world</code>, as it has a third segment which we don't match (<code>world</code>). When you provide <code>on</code> with a String then it matches it as an exact match (of one or more segments), if you provide a symbol it matches a single segment regardless of what it is.</p>

<p>Our current application will always greet the user with the same message, regardless of the second segment. If we want to change that, we need to access the value of the second segment. This is where the inbox comes in. The inbox is a hash, which in our example has a key <code>:name</code> with the value set to the segment. So let's use that:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.define <span class="pl-k">do</span>
  on(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) <span class="pl-k">do</span>
    on(<span class="pl-c1">:name</span>) <span class="pl-k">do</span>
      get <span class="pl-k">do</span>
        res.write(<span class="pl-s"><span class="pl-pds">"</span>Hello <span class="pl-pse">#{</span><span class="pl-s1">inbox[<span class="pl-c1">:name</span>]</span><span class="pl-pse"><span class="pl-s1">}</span></span>!<span class="pl-pds">"</span></span>)
      <span class="pl-k">end</span>
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>With this change, the visitor will now be greeted with what they provided in the URL. So for example <code>curl -i localhost:9292/hello/alice</code> will reply with <code>hello alice</code>. You can nest the <code>on</code> calls in any way you like, so you can also match URLs like <code>/people/:name/articles</code>.</p>

<h3>
<a id="handling-request-and-response" class="anchor" href="#handling-request-and-response" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Handling Request and Response</h3>

<p>When handling HTTP requests, you have a <code>req</code> and a <code>res</code> object available inside your <code>Tynn.define</code> block:</p>

<ul>
<li>
<code>req</code> is an instance of <a href="http://www.rubydoc.info/github/frodsan/tynn/master/Tynn/Request">Tynn::Request</a> and provides information about the request.</li>
<li>
<code>res</code> is an instance of <a href="http://www.rubydoc.info/github/frodsan/tynn/master/Tynn/Response">Tynn::Response</a> and provides information about the response.</li>
</ul>

<p>In this section of the tutorial, we will go through accessing parameters. For more information about routing, check out <a href="/routing-basics.html">the guide</a>. The request object <code>req</code> gives you access to all parameters. When we say "parameters" we mean two things:</p>

<ul>
<li>The data received from the <a href="https://en.wikipedia.org/wiki/Query_string">Query String</a>
</li>
<li>The data received from the <a href="https://en.wikipedia.org/wiki/HTTP_message_body">HTTP message body</a>
</li>
</ul>

<p>Let's start with the query string. The query string is a part of an URL and can therefore occur in every kind of request. It is a collection of key value pairs. The URL <code>http://localhost:9292/hello/alice?a=12&amp;b=hello</code> for example has two pairs of key and value: <code>a</code> has the value <code>"12"</code> and <code>b</code> has the value <code>"hello"</code>. We can access them via the <code>[]</code> method on Tynn::Request:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.define <span class="pl-k">do</span>
  on(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) <span class="pl-k">do</span>
    on(<span class="pl-c1">:name</span>) <span class="pl-k">do</span>
      get <span class="pl-k">do</span>
        res.write(<span class="pl-s"><span class="pl-pds">"</span>Hello <span class="pl-pse">#{</span><span class="pl-s1">inbox[<span class="pl-c1">:name</span>]</span><span class="pl-pse"><span class="pl-s1">}</span></span> with your 'a' being '<span class="pl-pse">#{</span><span class="pl-s1">req[<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>]</span><span class="pl-pse"><span class="pl-s1">}</span></span>'!<span class="pl-pds">"</span></span>)
      <span class="pl-k">end</span>
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Now let's try it out by sending the request via curl: <code>curl -i "http://localhost:9292/hello/alice?a=12&amp;b=hello"</code> and we will see <code>Hello alice with your 'a' being '12!'</code>. Be aware that the value will be <code>nil</code> when the key is not in the query string (it behaves like a Ruby Hash). Note that another name for this kind of parameter is a "Get parameter", because an HTML form using the GET method with use a query string to transmit its data. You can however use it with any method not just GET.</p>

<p>The other kind of parameters is the information stored in the HTTP message body. The body can contain any kind of data – for example JSON encoded data or binary data. One way this is used is when you submit an HTML form with the <code>POST</code> method. The body is then encoded in a way that is called "form URL encoded". The format is described <a href="https://en.wikipedia.org/wiki/Percent-encoding#The_application.2Fx-www-form-urlencoded_type">here</a> for example. curl speaks this encoding fluently, so we can use it like this: <code>curl -d "name=Daniel%20Stenberg&amp;occupation=Hacker" http://localhost:9292/hello/alice</code>. curl does a few things for us: It sets the request method to POST, sets the content type to <code>application/x-www-form-urlencoded</code>, determines the content length and sets the body. Now how to we react to that in our Tynn app?</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.define <span class="pl-k">do</span>
  on(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) <span class="pl-k">do</span>
    on(<span class="pl-c1">:name</span>) <span class="pl-k">do</span>
      post <span class="pl-k">do</span>
        res.write(<span class="pl-s"><span class="pl-pds">"</span>Created user '<span class="pl-pse">#{</span><span class="pl-s1">req[<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>]</span><span class="pl-pse"><span class="pl-s1">}</span></span>' with occupation '<span class="pl-pse">#{</span><span class="pl-s1">req[<span class="pl-s"><span class="pl-pds">'</span>occupation<span class="pl-pds">'</span></span>]</span><span class="pl-pse"><span class="pl-s1">}</span></span>'<span class="pl-pds">"</span></span>)
      <span class="pl-k">end</span>
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>If you try it out with <code>curl -d "name=Daniel%20Stenberg&amp;occupation=Hacker" http://localhost:9292/hello/alice</code> you will get a response stating <code>Created user 'Daniel Stenberg' with occupation 'Hacker'</code>. As you can see, we use the same method to access these parameters as we did for the parameters in the query part of our URL. Another common usage for the body is sending JSON encoded data, for example when talking to an API. We can do that with curl as follows (sending the same content, just encoded differently): <code>curl -H "Content-Type: application/json" -X POST -d '{"name": "Daniel Stenberg", "occupation": "Hacker"}' http://localhost:9292/hello/alice</code>. As Tynn doesn't understand JSON natively in the same way it does form encoded data, we have to do the following:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">"</span>json<span class="pl-pds">"</span></span>

<span class="pl-c1">Tynn</span>.define <span class="pl-k">do</span>
  on(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) <span class="pl-k">do</span>
    on(<span class="pl-c1">:name</span>) <span class="pl-k">do</span>
      post <span class="pl-k">do</span>
        <span class="pl-k">if</span> req.content_type <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>application/json<span class="pl-pds">"</span></span>
          user <span class="pl-k">=</span> <span class="pl-c1">JSON</span>.parse(req.body.read)
          res.write(<span class="pl-s"><span class="pl-pds">"</span>Created user '<span class="pl-pse">#{</span><span class="pl-s1">user[<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>]</span><span class="pl-pse"><span class="pl-s1">}</span></span>' with occupation '<span class="pl-pse">#{</span><span class="pl-s1">user[<span class="pl-s"><span class="pl-pds">'</span>occupation<span class="pl-pds">'</span></span>]</span><span class="pl-pse"><span class="pl-s1">}</span></span>'<span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
      <span class="pl-k">end</span>
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>We do two things here: We check if the content type is set correctly, and if it is, we parse the body of the request as JSON and then do what we did before. The result therefore will be the same as in the form encoded example. Note that not all HTTP methods support sending a body. Notably GET and HEAD <strong>do not support</strong> it.</p>

<h3>
<a id="composing-applications" class="anchor" href="#composing-applications" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Composing Applications</h3>

<p>At this point you may wonder if you need to put your entire routing logic or even application into one giant Tynn application. No, you don't need to. In fact, composing applications is one of the guiding principles of Tynn.</p>

<p>In our examples so far we only had one Tynn app. What if we want to create a second one?</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Users<span class="pl-e"> &lt; Tynn</span></span>
<span class="pl-k">end</span>

<span class="pl-c1">Users</span>.define <span class="pl-k">do</span>
  <span class="pl-c"># ... add handlers here</span>
<span class="pl-k">end</span></pre></div>

<p>We can run a Tynn inside of another app. We can for example use this to run our <code>Users</code> app for all routes that start with <code>/users</code> like this:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Users<span class="pl-e"> &lt; Tynn</span></span>
<span class="pl-k">end</span>

<span class="pl-c1">Users</span>.define <span class="pl-k">do</span>
  get <span class="pl-k">do</span>
    res.write(<span class="pl-s"><span class="pl-pds">"</span>All the users<span class="pl-pds">"</span></span>)
  <span class="pl-k">end</span>

  on(<span class="pl-c1">:id</span>) <span class="pl-k">do</span>
    get <span class="pl-k">do</span>
      res.write(<span class="pl-s"><span class="pl-pds">"</span>Only the user with ID <span class="pl-pse">#{</span><span class="pl-s1">inbox[<span class="pl-c1">:id</span>]</span><span class="pl-pse"><span class="pl-s1">}</span></span><span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">Tynn</span>.define <span class="pl-k">do</span>
  on(<span class="pl-s"><span class="pl-pds">"</span>users<span class="pl-pds">"</span></span>) <span class="pl-k">do</span>
    run(<span class="pl-c1">Users</span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h3>
<a id="extending-tynn" class="anchor" href="#extending-tynn" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Extending Tynn</h3>

<p>Tynn is minimal. You might miss features from time to time. Tynn is designed to be extended, so you add the functionality that you need. There are two ways to extend it:</p>

<ul>
<li>
<a href="/plugins.html">Plugins</a> via <code>plugin</code>: Add class and instance methods to your application.</li>
<li>
<a href="/middleware.html">Middleware</a> via <code>use</code>: Rewrite requests before they enter your application and responses after they left your application.</li>
</ul>

<p>Tynn also ships with some <a href="/default-plugins.html">default plugins</a> that you can add to your application if you need them.</p>

<h2>
<a id="routing-basics" class="anchor" href="#routing-basics" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Routing basics</h2>

<h3>
<a id="halting" class="anchor" href="#halting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Halting</h3>

<p>To immediately stop a request within a route, you can use the <code>halt</code> method.</p>

<div class="highlight highlight-source-ruby"><pre>halt([status, headers, body])</pre></div>

<p>You can use <code>res.finish</code> to return a response as per Rack's specification.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">if</span> current_user.nil?
  res.redirect(<span class="pl-s"><span class="pl-pds">"</span>/login<span class="pl-pds">"</span></span>)

  halt(res.finish)
<span class="pl-k">else</span>
  <span class="pl-c"># do something else ...</span>
<span class="pl-k">end</span></pre></div>

<h2>
<a id="middleware" class="anchor" href="#middleware" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Middleware</h2>

<p>Tynn runs on <a href="https://github.com/rack/rack">Rack</a>. Therefore it is possible
to use Rack middleware in Tynn. This is how you add a middleware (for example
<code>YourMiddleware</code>) to your app:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.use(<span class="pl-c1">YourMiddleware</span>)</pre></div>

<p>You can use any Rack middleware to your app, it is not specific to Tynn. You
can find a list of Rack middleware <a href="https://github.com/rack/rack/wiki/list-of-middleware">here</a>.</p>

<h2>
<a id="plugins" class="anchor" href="#plugins" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Plugins</h2>

<p>A way to extend Tynn is to use the plugin API. A plugin is just a module which can contain any of the following rules:</p>

<ul>
<li><p>If a <code>ClassMethods</code> module is defined, it extends the application class.</p></li>
<li><p>If a <code>InstanceMethods</code> module is defined, it's included in the application.</p></li>
<li><p>If a <code>setup</code> method is defined, it will be called last. This method can be used to configure the plugin.</p></li>
</ul>

<p>The following is a complete example of the plugin API.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">"</span>valuta<span class="pl-pds">"</span></span>

<span class="pl-k">module</span> <span class="pl-en">CurrencyHelper</span>
  <span class="pl-k">def</span> <span class="pl-en">self.setup</span>(<span class="pl-smi">app</span>, <span class="pl-smi">currency</span>: <span class="pl-s"><span class="pl-pds">"</span>$<span class="pl-pds">"</span></span>)
    <span class="pl-v">self</span>.currency <span class="pl-k">=</span> currency
  <span class="pl-k">end</span>

  <span class="pl-k">module</span> <span class="pl-en">ClassMethods</span>
    <span class="pl-k">def</span> <span class="pl-en">currency</span>
      <span class="pl-smi">@currency</span>
    <span class="pl-k">end</span>

    <span class="pl-k">def</span> <span class="pl-en">currency=</span>(<span class="pl-smi">currency</span>)
      <span class="pl-smi">@currency</span> <span class="pl-k">=</span> currency
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>

  <span class="pl-k">module</span> <span class="pl-en">InstanceMethods</span>
    <span class="pl-k">def</span> <span class="pl-en">to_currency</span>(<span class="pl-smi">value</span>)
      <span class="pl-c1">Valuta</span>.convert(value, <span class="pl-c1">prefix:</span> <span class="pl-v">self</span>.class.currency)
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>To load the plugin into the application, use the <code>plugin</code> method.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">App</span>.plugin(<span class="pl-c1">CurrencyHelper</span>, <span class="pl-c1">currency:</span> <span class="pl-s"><span class="pl-pds">"</span>$<span class="pl-pds">"</span></span>)</pre></div>

<p>Here is the plugin in action:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">App</span>.currency <span class="pl-c"># =&gt; "$"</span>

<span class="pl-c1">App</span>.define <span class="pl-k">do</span>
  get <span class="pl-k">do</span>
    res.write(to_currency(<span class="pl-c1">4567</span>))
  <span class="pl-k">end</span>
<span class="pl-k">end</span>
<span class="pl-c"># GET / =&gt; 200 $4,567</span></pre></div>

<h2>
<a id="settings" class="anchor" href="#settings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Settings</h2>

<p>Each application has a <code>settings</code> hash where configuration can be stored. By default, settings are inherited.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.set(<span class="pl-c1">:layout</span>, <span class="pl-s"><span class="pl-pds">"</span>layout<span class="pl-pds">"</span></span>)

<span class="pl-k">class</span> <span class="pl-en">Guests<span class="pl-e"> &lt; Tynn</span></span>; <span class="pl-k">end</span>
<span class="pl-k">class</span> <span class="pl-en">Users<span class="pl-e"> &lt; Tynn</span></span>; <span class="pl-k">end</span>
<span class="pl-k">class</span> <span class="pl-en">Adminds<span class="pl-e"> &lt; Tynn</span></span>; <span class="pl-k">end</span>

<span class="pl-c1">Users</span>.set(<span class="pl-c1">:layout</span>, <span class="pl-s"><span class="pl-pds">"</span>users/layout<span class="pl-pds">"</span></span>)
<span class="pl-c1">Admins</span>.set(<span class="pl-c1">:layout</span>, <span class="pl-s"><span class="pl-pds">"</span>admins/layout<span class="pl-pds">"</span></span>)

<span class="pl-c1">Guests</span>.settings[<span class="pl-c1">:layout</span>] <span class="pl-c"># =&gt; "layout"</span>
<span class="pl-c1">Users</span>.settings[<span class="pl-c1">:layout</span>]  <span class="pl-c"># =&gt; "users/layout"</span>
<span class="pl-c1">Admins</span>.settings[<span class="pl-c1">:layout</span>] <span class="pl-c"># =&gt; "admins/layout"</span></pre></div>

<p>This features comes in handy when authoring plugins.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">module</span> <span class="pl-en">CurrencyHelper</span>
  <span class="pl-k">module</span> <span class="pl-en">ClassMethods</span>
    <span class="pl-k">def</span> <span class="pl-en">currency=</span>(<span class="pl-smi">currency</span>)
      set(<span class="pl-c1">:currency</span>, currency)
    <span class="pl-k">end</span>

    <span class="pl-k">def</span> <span class="pl-en">currency</span>
      settings.fetch(<span class="pl-c1">:currency</span>, <span class="pl-s"><span class="pl-pds">"</span>$<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h2>
<a id="default-plugins" class="anchor" href="#default-plugins" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Default Plugins</h2>

<p>Tynn ships with a set of default plugins:</p>

<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://api.tynn.xyz/2.0.0/Tynn/Environment.html">Tynn::Environment</a></td>
<td>Adds helper methods to get and check the current environment.</td>
</tr>
<tr>
<td><a href="http://api.tynn.xyz/2.0.0/Tynn/JSON.html">Tynn::JSON</a></td>
<td>Adds helper methods for json generation.</td>
</tr>
<tr>
<td><a href="http://api.tynn.xyz/2.0.0/Tynn/Protection.html">Tynn::Protection</a></td>
<td>Adds security measures against common attacks.</td>
</tr>
<tr>
<td><a href="http://api.tynn.xyz/2.0.0/Tynn/Render.html">Tynn::Render</a></td>
<td>Adds support for rendering templates through different engines.</td>
</tr>
<tr>
<td><a href="http://api.tynn.xyz/2.0.0/Tynn/Session.html">Tynn::Session</a></td>
<td>Adds simple cookie based session management.</td>
</tr>
<tr>
<td><a href="http://api.tynn.xyz/2.0.0/Tynn/Static.html">Tynn::Static</a></td>
<td>Adds support for static files (javascript files, images, etc.).</td>
</tr>
</tbody>
</table>

<p>The following sections cover the default plugins and extensions shipped with Tynn.</p>

<h2>
<a id="environments" class="anchor" href="#environments" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Environments</h2>

<p>Tynn ships with <a href="http://api.tynn.xyz/2.0.0/Tynn/Environment.html">Tynn::Environment</a> to set and check the current environment for the application.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">"</span>tynn<span class="pl-pds">"</span></span>
<span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">"</span>tynn/environment<span class="pl-pds">"</span></span>

<span class="pl-c1">Tynn</span>.plugin(<span class="pl-c1">Tynn</span>::<span class="pl-c1">Environment</span>)</pre></div>

<p>The default environment is based on the <code>RACK_ENV</code> environment variable.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">ENV</span>[<span class="pl-s"><span class="pl-pds">"</span>RACK_ENV<span class="pl-pds">"</span></span>]
<span class="pl-c"># =&gt; "test"</span>

<span class="pl-c1">Tynn</span>.environment
<span class="pl-c"># =&gt; :test</span></pre></div>

<p>If <code>ENV["RACK_ENV"]</code> is <code>nil</code>, the default value is <code>:development</code>.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.environment
<span class="pl-c"># =&gt; :development</span></pre></div>

<p>To change the current environment, use the <code>environment=</code> method.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.environment <span class="pl-k">=</span> <span class="pl-c1">:development</span>

<span class="pl-c1">Tynn</span>.environment
<span class="pl-c"># =&gt; :development</span></pre></div>

<p>To check the current environment, use: <code>development?</code>, <code>test?</code>,
<code>production?</code> or <code>staging?</code>.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.plugin(<span class="pl-c1">Tynn</span>::<span class="pl-c1">Protection</span>, <span class="pl-c1">ssl:</span> <span class="pl-c1">Tynn</span>.production?)</pre></div>

<p>Perform operations on specific environments with the <code>configure</code> method.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.configure(<span class="pl-c1">:development</span>) <span class="pl-k">do </span>|<span class="pl-smi">app</span>|
  app.use(<span class="pl-c1">Tynn</span>::<span class="pl-c1">Static</span>, <span class="pl-s"><span class="pl-pds">%w(</span>/js /css /images<span class="pl-pds">)</span></span>)
<span class="pl-k">end</span>

<span class="pl-c1">Tynn</span>.configure(<span class="pl-c1">:production</span>) <span class="pl-k">do </span>|<span class="pl-smi">app</span>|
  app.use(<span class="pl-c1">Tynn</span>::<span class="pl-c1">SSL</span>)
<span class="pl-k">end</span></pre></div>

<h2>
<a id="method-override" class="anchor" href="#method-override" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Method Override</h2>

<p>HTML Forms only support GET and POST requests. To perform other actions such as PUT, PATCH or DELETE, use the <a href="http://www.rubydoc.info/github/rack/rack/Rack/MethodOverride">Rack::MethodOverride</a> middleware. Note that there is no need to add any new dependencies to the application as it's included in Rack already.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.use(<span class="pl-c1">Rack</span>::<span class="pl-c1">MethodOverride</span>)</pre></div>

<p>This uses a POST form to simulate a request with a non-supported method. In order to succeed, a hidden input field, with the name <code>_method</code> and the method name as the value, needs to be included. The following example simulates a PUT
request.</p>

<div class="highlight highlight-text-html-basic"><pre>&lt;<span class="pl-ent">form</span> <span class="pl-e">method</span>=<span class="pl-s"><span class="pl-pds">"</span>POST<span class="pl-pds">"</span></span> <span class="pl-e">action</span>=<span class="pl-s"><span class="pl-pds">"</span>/posts/1<span class="pl-pds">"</span></span>&gt;
  &lt;<span class="pl-ent">input</span> <span class="pl-e">type</span>=<span class="pl-s"><span class="pl-pds">"</span>hidden<span class="pl-pds">"</span></span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>_method<span class="pl-pds">"</span></span> <span class="pl-e">value</span>=<span class="pl-s"><span class="pl-pds">"</span>PUT<span class="pl-pds">"</span></span>&gt;
  <span class="pl-c">&lt;!-- ... --&gt;</span>
&lt;/<span class="pl-ent">form</span>&gt;</pre></div>

<p>Now, this will trigger the <code>put</code> matcher in the application.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Posts</span>.define <span class="pl-k">do</span>
  put <span class="pl-k">do</span>
    post.update(req.params[<span class="pl-s"><span class="pl-pds">"</span>post<span class="pl-pds">"</span></span>])
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h2>
<a id="static-files" class="anchor" href="#static-files" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Static Files</h2>

<p>Tynn ships with <a href="http://api.tynn.xyz/2.0.0/Tynn/Static.html">Tynn::Static</a> to serve static files such as images, CSS, JavaScript and others.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">"</span>tynn<span class="pl-pds">"</span></span>
<span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">"</span>tynn/static<span class="pl-pds">"</span></span>

<span class="pl-c1">Tynn</span>.plugin(<span class="pl-c1">Tynn</span>::<span class="pl-c1">Static</span>, <span class="pl-s"><span class="pl-pds">%w(</span>/js /css /images<span class="pl-pds">)</span></span>)</pre></div>

<p>By default, static files are served from the folder <code>public</code> in the current directory. You can specify a different location by passing the <code>:root</code> option:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.plugin(<span class="pl-c1">Tynn</span>::<span class="pl-c1">Static</span>, <span class="pl-s"><span class="pl-pds">%w(</span>/js /css /images<span class="pl-pds">)</span></span>, <span class="pl-c1">root:</span> <span class="pl-s"><span class="pl-pds">"</span>assets<span class="pl-pds">"</span></span>)</pre></div>

<p>As you can see in the table below, the name of static directory is not included in the URL because the files are looked up relative to that directory.</p>

<table>
<thead>
<tr>
<th>File</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>./public/js/application.js</td>
<td><a href="http://example.org/js/application.js">http://example.org/js/application.js</a></td>
</tr>
<tr>
<td>./public/css/application.css</td>
<td><a href="http://example.org/css/application.css">http://example.org/css/application.css</a></td>
</tr>
<tr>
<td>./public/images/logo.png</td>
<td><a href="http://example.org/images/logo.png">http://example.org/images/logo.png</a></td>
</tr>
</tbody>
</table>

<p>It's important to mention that the path of the static directory path is relative to the directory where you run the application. If you run the application from another directory, it's safer to use an absolute path:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Tynn</span>.plugin(
  <span class="pl-c1">Tynn</span>::<span class="pl-c1">Static</span>,
  <span class="pl-s"><span class="pl-pds">%w(</span>/js /css /images<span class="pl-pds">)</span></span>,
  <span class="pl-c1">root:</span> <span class="pl-c1">File</span>.expand_path(<span class="pl-s"><span class="pl-pds">"</span>public<span class="pl-pds">"</span></span>, __dir__)
)</pre></div>

<h2>
<a id="testing" class="anchor" href="#testing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Testing</h2>

<p>Tynn ships with <a href="http://api.tynn.xyz/2.0.0/Tynn/Test.html">Tynn::Test</a>, a simple helper class to simulate requests to your application.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">"</span>tynn<span class="pl-pds">"</span></span>
<span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">"</span>tynn/test<span class="pl-pds">"</span></span>

<span class="pl-c1">Tynn</span>.define <span class="pl-k">do</span>
  root <span class="pl-k">do</span>
    res.write(<span class="pl-s"><span class="pl-pds">"</span>hei<span class="pl-pds">"</span></span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

app <span class="pl-k">=</span> <span class="pl-c1">Tynn</span>::<span class="pl-c1">Test</span>.<span class="pl-k">new</span>
app.get(<span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>)

<span class="pl-c1">200</span>   <span class="pl-k">==</span> app.res.status <span class="pl-c"># =&gt; true</span>
<span class="pl-s"><span class="pl-pds">"</span>hei<span class="pl-pds">"</span></span> <span class="pl-k">==</span> app.res.body   <span class="pl-c"># =&gt; true</span></pre></div>

<p><a href="http://api.tynn.xyz/2.0.0/Tynn/Test.html">Tynn::Test</a> is test-framework agnostic. The following example uses <a href="https://github.com/seattlerb/minitest">Minitest</a>:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">"</span>minitest/autorun<span class="pl-pds">"</span></span>
<span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">"</span>tynn/test<span class="pl-pds">"</span></span>

<span class="pl-k">class</span> <span class="pl-en">GuestsRouteTest<span class="pl-e"> &lt; Minitest::Test</span></span>
  <span class="pl-k">def</span> <span class="pl-en">setup</span>
    <span class="pl-smi">@app</span> <span class="pl-k">=</span> <span class="pl-c1">Tynn</span>::<span class="pl-c1">Test</span>.<span class="pl-k">new</span>
  <span class="pl-k">end</span>

  <span class="pl-k">def</span> <span class="pl-en">test_home</span>
    <span class="pl-smi">@app</span>.get(<span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>)

    assert_equal <span class="pl-c1">200</span>, <span class="pl-smi">@app</span>.res.status
    assert_equal <span class="pl-s"><span class="pl-pds">"</span>Hello World!<span class="pl-pds">"</span></span>, <span class="pl-smi">@app</span>.res.body
    assert_equal <span class="pl-s"><span class="pl-pds">"</span>text/html<span class="pl-pds">"</span></span>, <span class="pl-smi">@app</span>.res[<span class="pl-s"><span class="pl-pds">"</span>Content-Type<span class="pl-pds">"</span></span>]
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>If this is not of your flavor, you can use any Rack-based testing library or framework, like: <a href="https://github.com/brynary/rack-test">Rack::Test</a> or <a href="https://github.com/jnicklas/capybara">Capybara</a>.</p>

<h2>
<a id="changelog" class="anchor" href="#changelog" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Changelog</h2>

<p>To learn about new features, bug fixes, and changes, please refer to the <a href="https://github.com/frodsan/tynn/blob/master/CHANGELOG.md">CHANGELOG</a>.</p>

<h2>
<a id="development" class="anchor" href="#development" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Development</h2>

<p>Fork the project with:</p>

<pre><code>$ git clone git@github.com:frodsan/tynn.git
</code></pre>

<p>To install dependencies, use:</p>

<pre><code>$ bundle install
</code></pre>

<p>To run the test suite, do:</p>

<pre><code>$ rake test
</code></pre>

<h2>
<a id="contributing" class="anchor" href="#contributing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Contributing</h2>

<p>Use <a href="https://github.com/frodsan/tynn/issues">GitHub Issues</a> for reporting bugs, discussing features and general feedback. If you've found a problem in Tynn, be sure to check the <a href="https://github.com/frodsan/tynn/issues?state=closed">past issues</a> before open a new one.</p>

<h2>
<a id="code-status" class="anchor" href="#code-status" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Code Status</h2>

<p><a href="https://travis-ci.org/frodsan/tynn"><img src="https://travis-ci.org/frodsan/tynn.svg?branch=master" alt="Build Status"></a></p>

<p><a href="https://travis-ci.org/frodsan/tynn/builds"><img src="https://buildstats.info/travisci/chart/frodsan/tynn?branch=master" alt="Build History"></a></p>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>License</h2>

<p>Tynn is released under the <a href="http://www.opensource.org/licenses/MIT">MIT License</a>.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/frodsan/tynn">Tynn</a> is maintained by <a href="https://github.com/frodsan">frodsan</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
