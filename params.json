{
  "name": "Tynn",
  "tagline": "A thin library for web development in Ruby",
  "body": "# Tynn\r\n\r\nA thin library for web development in Ruby.\r\n\r\n* [Installation](#installation)\r\n* [Getting Started](#getting-started)\r\n  * [Hello World!](#hello-world)\r\n  * [Capturing Path Segments and the Inbox](#capturing-path-segments-and-the-inbox)\r\n  * [Handling Request and Response](#handling-request-and-response)\r\n  * [Composing Applications](#composing-applications)\r\n  * [Extending Tynn](#extending-tynn)\r\n* [Routing Basics](#routing-basics)\r\n  * [Halting](#halting)\r\n* [Middleware](#middleware)\r\n* [Settings](#settings)\r\n* [Environments](#environments)\r\n* [Static Files](#static-files)\r\n* [Testing](#testing)\r\n* [API Reference](http://api.tynn.xyz/)\r\n* [Changelog](#changelog)\r\n* [Development](#development)\r\n* [Contributing](#contributing)\r\n* [Code Status](#code-status)\r\n* [License](#license)\r\n\r\n**NOTE: Tynn 2 is in an alpha phase. Anything can change at any time. Usage is not recommended until a stable version gets released.**\r\n\r\n## Installation\r\n\r\n```\r\n$ gem install tynn\r\n```\r\n\r\n## Getting Started\r\n\r\nIn this tutorial we will assume that you have basic knowledge about HTTP and Ruby. You will learn about Rack, Tynn and cURL along the way. To code along all you need to do is `gem install tynn` and then create a folder that should contain your first app.\r\n\r\n### Hello World!\r\n\r\nTynn is a routing library that sits on top of Rack. So in order to get your first Tynn app running, we need to write a `config.ru` file. This file is used by Rack to find an application and run it. The most basic version of `config.ru` file looks like this:\r\n\r\n```ruby\r\nrequire File.expand_path(\"app\", __dir__)\r\n\r\nrun(Tynn)\r\n```\r\n\r\nThis will require the `app.rb` file in the current directory and then run the Rack application that is contained in it. So let's write the `app.rb` file:\r\n\r\n```ruby\r\nrequire \"tynn\"\r\n\r\nTynn.define do\r\n  res.write(\"Hello World!\")\r\nend\r\n```\r\n\r\nIn this file we first require the Tynn library, then we define our application. It will write \"Hello World\" to something called `res`. In Tynn, `res` is the result of the request. So in other words: Our application will answer with `\"Hello World\"`.\r\n\r\nTo run this application now, we will use a commandline tool called `rackup`. It is included in the Rack gem, so you already have it installed. You run it like this:\r\n\r\n```\r\nrackup\r\n```\r\n\r\nIt will then boot up and tell you something like this:\r\n\r\n```\r\n[2015-11-30 17:27:37] INFO  WEBrick 1.3.1\r\n[2015-11-30 17:27:37] INFO  ruby 2.2.2 (2015-04-13) [x86_64-linux]\r\n[2015-11-30 17:27:37] INFO  WEBrick::HTTPServer#start: pid=25355 port=9292\r\n```\r\n\r\nThis means that we are using [WEBrick](http://ruby-doc.org/stdlib-2.2.3/libdoc/webrick/rdoc/index.html) from the Ruby standard library as our web server, and we are using the port 9292. So now you can either type `localhost:9292` in your browser of choice or use curl. curl is probably installed on your system already. If it is not, you can find information on how to install it [here](http://curl.haxx.se/docs/install.html). In a second terminal (while your server keeps running in the first one), type:\r\n\r\n```\r\ncurl localhost:9292\r\n```\r\n\r\nThe result will be:\r\n\r\n```\r\nHello World!\r\n```\r\n\r\nCongratulations, you now have your first working Tynn app! But wait, on what path does it listen? As we've seen above, it definitely listens on the root path. But what about the other paths? Let's try it out with `curl localhost:9292/somepath` – and you will see the same result! Our app listens on all paths. Let's change that to only responding to the root path:\r\n\r\n```ruby\r\nTynn.define do\r\n  root do\r\n    res.write(\"Hello World!\")\r\n  end\r\nend\r\n```\r\n\r\nNow `curl localhost:9292` will still return the greeting, but `curl localhost:9292/somepath` will return an empty response. As the request was not matched, it will also return a 404 status code which means \"not found\" in HTTP speak. You can check that with curl using the `-i` option: `curl -i localhost:9292/somepath`. If you want to learn more about status codes, check out the [Wikipedia page](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes).\r\n\r\nOk, so now you know how to react to the root path only. Let's continue with checking for the HTTP method. If you are not familiar with HTTP methods, check out [this Wikipedia page](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods). By default, curl does a GET request. Let us try a POST request instead: `curl -d \"\" localhost:9292` (the `\"\"` is just an empty body for the post request). The result is the same as for the GET request. How can we restrict it to only react to GET requests?\r\n\r\n```ruby\r\nTynn.define do\r\n  root do\r\n    get do\r\n      res.write(\"Hello World!\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nNow you might want to match to another path than the root path as well, so let's try this:\r\n\r\n```ruby\r\nTynn.define do\r\n  root do\r\n    get do\r\n      res.write(\"Hello World!\")\r\n    end\r\n  end\r\n\r\n  on(\"tynn\") do\r\n    get do\r\n      res.write(\"Hello Tynn!\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nNow we will get `Hello World` when we GET the root path, `Hello Tynn` when we GET the Tynn path and a 404 when we do anything else. Now one more thing about `on`: It is very flexible. You can either give it a single segment of the path (like above) or give it an entire path (like `on('a/pretty/long/path')`). You can also nest it, and this is what makes it really flexible:\r\n\r\n```ruby\r\non(\"hello\") do\r\n  on(\"tynn\") do\r\n    get do\r\n      res.write(\"Hello Tynn!\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nNow you know the basics of Tynn – but there is still more to learn. Keep exploring this page!\r\n\r\n### Capturing Path Segments and the Inbox\r\n\r\nWe now know how to handle static URLs and different request methods. But what about dynamic parts in the request, like an ID or the name of a blog post? Tynn has you covered:\r\n\r\n```ruby\r\nTynn.define do\r\n  on(\"hello\") do\r\n    on(:name) do\r\n      get do\r\n        res.write(\"Hello Tynn!\")\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis will work for all URLs that have `hello` as their first segment and some other string as the second segment. For example `/hello/tynn` or `/hello/world`. Notice however that it will not match `/hello/beautiful/world`, as it has a third segment which we don't match (`world`). When you provide `on` with a String then it matches it as an exact match (of one or more segments), if you provide a symbol it matches a single segment regardless of what it is.\r\n\r\nOur current application will always greet the user with the same message, regardless of the second segment. If we want to change that, we need to access the value of the second segment. This is where the inbox comes in. The inbox is a hash, which in our example has a key `:name` with the value set to the segment. So let's use that:\r\n\r\n```ruby\r\nTynn.define do\r\n  on(\"hello\") do\r\n    on(:name) do\r\n      get do\r\n        res.write(\"Hello #{inbox[:name]}!\")\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWith this change, the visitor will now be greeted with what they provided in the URL. So for example `curl -i localhost:9292/hello/alice` will reply with `hello alice`. You can nest the `on` calls in any way you like, so you can also match URLs like `/people/:name/articles`.\r\n\r\n### Handling Request and Response\r\n\r\nWhen handling HTTP requests, you have a `req` and a `res` object available inside your `Tynn.define` block:\r\n\r\n* `req` is an instance of [Tynn::Request](http://www.rubydoc.info/github/frodsan/tynn/master/Tynn/Request) and provides information about the request.\r\n* `res` is an instance of [Tynn::Response](http://www.rubydoc.info/github/frodsan/tynn/master/Tynn/Response) and provides information about the response.\r\n\r\nIn this section of the tutorial, we will go through accessing parameters. For more information about routing, check out [the guide](/routing-basics.html). The request object `req` gives you access to all parameters. When we say \"parameters\" we mean two things:\r\n\r\n* The data received from the [Query String](https://en.wikipedia.org/wiki/Query_string)\r\n* The data received from the [HTTP message body](https://en.wikipedia.org/wiki/HTTP_message_body)\r\n\r\nLet's start with the query string. The query string is a part of an URL and can therefore occur in every kind of request. It is a collection of key value pairs. The URL `http://localhost:9292/hello/alice?a=12&b=hello` for example has two pairs of key and value: `a` has the value `\"12\"` and `b` has the value `\"hello\"`. We can access them via the `[]` method on Tynn::Request:\r\n\r\n```ruby\r\nTynn.define do\r\n  on(\"hello\") do\r\n    on(:name) do\r\n      get do\r\n        res.write(\"Hello #{inbox[:name]} with your 'a' being '#{req['a']}'!\")\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nNow let's try it out by sending the request via curl: `curl -i \"http://localhost:9292/hello/alice?a=12&b=hello\"` and we will see `Hello alice with your 'a' being '12!'`. Be aware that the value will be `nil` when the key is not in the query string (it behaves like a Ruby Hash). Note that another name for this kind of parameter is a \"Get parameter\", because an HTML form using the GET method with use a query string to transmit its data. You can however use it with any method not just GET.\r\n\r\nThe other kind of parameters is the information stored in the HTTP message body. The body can contain any kind of data – for example JSON encoded data or binary data. One way this is used is when you submit an HTML form with the `POST` method. The body is then encoded in a way that is called \"form URL encoded\". The format is described [here](https://en.wikipedia.org/wiki/Percent-encoding#The_application.2Fx-www-form-urlencoded_type) for example. curl speaks this encoding fluently, so we can use it like this: `curl -d \"name=Daniel%20Stenberg&occupation=Hacker\" http://localhost:9292/hello/alice`. curl does a few things for us: It sets the request method to POST, sets the content type to `application/x-www-form-urlencoded`, determines the content length and sets the body. Now how to we react to that in our Tynn app?\r\n\r\n```ruby\r\nTynn.define do\r\n  on(\"hello\") do\r\n    on(:name) do\r\n      post do\r\n        res.write(\"Created user '#{req['name']}' with occupation '#{req['occupation']}'\")\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nIf you try it out with `curl -d \"name=Daniel%20Stenberg&occupation=Hacker\" http://localhost:9292/hello/alice` you will get a response stating `Created user 'Daniel Stenberg' with occupation 'Hacker'`. As you can see, we use the same method to access these parameters as we did for the parameters in the query part of our URL. Another common usage for the body is sending JSON encoded data, for example when talking to an API. We can do that with curl as follows (sending the same content, just encoded differently): `curl -H \"Content-Type: application/json\" -X POST -d '{\"name\": \"Daniel Stenberg\", \"occupation\": \"Hacker\"}' http://localhost:9292/hello/alice`. As Tynn doesn't understand JSON natively in the same way it does form encoded data, we have to do the following:\r\n\r\n```ruby\r\nrequire \"json\"\r\n\r\nTynn.define do\r\n  on(\"hello\") do\r\n    on(:name) do\r\n      post do\r\n        if req.content_type == \"application/json\"\r\n          user = JSON.parse(req.body.read)\r\n          res.write(\"Created user '#{user['name']}' with occupation '#{user['occupation']}'\")\r\n        end\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWe do two things here: We check if the content type is set correctly, and if it is, we parse the body of the request as JSON and then do what we did before. The result therefore will be the same as in the form encoded example. Note that not all HTTP methods support sending a body. Notably GET and HEAD **do not support** it.\r\n\r\n### Composing Applications\r\n\r\nAt this point you may wonder if you need to put your entire routing logic or even application into one giant Tynn application. No, you don't need to. In fact, composing applications is one of the guiding principles of Tynn.\r\n\r\nIn our examples so far we only had one Tynn app. What if we want to create a second one?\r\n\r\n```ruby\r\nclass Users < Tynn\r\nend\r\n\r\nUsers.define do\r\n  # ... add handlers here\r\nend\r\n```\r\n\r\nWe can run a Tynn inside of another app. We can for example use this to run our `Users` app for all routes that start with `/users` like this:\r\n\r\n```ruby\r\nclass Users < Tynn\r\nend\r\n\r\nUsers.define do\r\n  get do\r\n    res.write(\"All the users\")\r\n  end\r\n\r\n  on(:id) do\r\n    get do\r\n      res.write(\"Only the user with ID #{inbox[:id]}\")\r\n    end\r\n  end\r\nend\r\n\r\nTynn.define do\r\n  on(\"users\") do\r\n    run(Users)\r\n  end\r\nend\r\n```\r\n\r\n### Extending Tynn\r\n\r\nTynn is minimal. You might miss features from time to time. Tynn is designed to be extended, so you add the functionality that you need. There are two ways to extend it:\r\n\r\n* [Plugins](/plugins.html) via `plugin`: Add class and instance methods to your application.\r\n* [Middleware](/middleware.html) via `use`: Rewrite requests before they enter your application and responses after they left your application.\r\n\r\nTynn also ships with some [default plugins](/default-plugins.html) that you can add to your application if you need them.\r\n\r\n## Routing basics\r\n\r\n### Halting\r\n\r\nTo immediately stop a request within a route, you can use the `halt` method.\r\n\r\n```ruby\r\nhalt([status, headers, body])\r\n```\r\n\r\nYou can use `res.finish` to return a response as per Rack's specification.\r\n\r\n```ruby\r\nif current_user.nil?\r\n  res.redirect(\"/login\")\r\n\r\n  halt(res.finish)\r\nelse\r\n  # do something else ...\r\nend\r\n```\r\n\r\n## Middleware\r\n\r\nTynn runs on [Rack](https://github.com/rack/rack). Therefore it is possible\r\nto use Rack middleware in Tynn. This is how you add a middleware (for example\r\n`YourMiddleware`) to your app:\r\n\r\n```ruby\r\nTynn.use(YourMiddleware)\r\n```\r\n\r\nYou can use any Rack middleware to your app, it is not specific to Tynn. You\r\ncan find a list of Rack middleware [here][middleware].\r\n\r\n### Example Usage: Allow method override\r\n\r\nHTML Forms currently only support GET and POST requests. You may want to have\r\na form that performs other actions such as PUT though. The usual solution to\r\nsimulate a PUT is using a POST form, but adding a hidden input field with the\r\nname `_method` and the value `put`. For example:\r\n\r\n```html\r\n<form method=\"post\" action=\"/update\">\r\n  <input type=\"hidden\" name=\"_method\" value=\"put\">\r\n  ...\r\n</form>\r\n```\r\n\r\nIn Tynn this would however trigger the `post` action, as it is send as\r\na post request from your browser. With a middleware we can now rewrite\r\nthis request and change the method to be `PUT`. There is a middleware\r\ncalled [Rack::MethodOverride][method-override] included in Rack that\r\ndoes exactly that, so let's add it to our Tynn app:\r\n\r\n```ruby\r\nTynn.use(Rack::MethodOverride)\r\n```\r\n\r\nNow this will trigger the `put` action in your app. It will also work for\r\nother missing methods like `DELETE`. Note that you do not need to add any\r\nnew dependencies to your application as it is included in Rack already.\r\n\r\n[middleware]: https://github.com/rack/rack/wiki/list-of-middleware\r\n[method-override]: https://github.com/rack/rack/blob/master/lib/rack/method_override.rb\r\n\r\n## Settings\r\n\r\nEach application has a `settings` hash where configuration can be stored. By default, settings are inherited.\r\n\r\n```ruby\r\nTynn.set(:layout, \"layout\")\r\n\r\nclass Guests < Tynn; end\r\nclass Users < Tynn; end\r\nclass Adminds < Tynn; end\r\n\r\nUsers.set(:layout, \"users/layout\")\r\nAdmins.set(:layout, \"admins/layout\")\r\n\r\nGuests.settings[:layout] # => \"layout\"\r\nUsers.settings[:layout]  # => \"users/layout\"\r\nAdmins.settings[:layout] # => \"admins/layout\"\r\n```\r\n\r\nThis features comes in handy when authoring plugins.\r\n\r\n```ruby\r\nmodule AppName\r\n  module ClassMethods\r\n    def app_name=(name)\r\n      set(:app_name, name)\r\n    end\r\n\r\n    def app_name\r\n      settings.fetch(:app_name, \"MyApp\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n## Environments\r\n\r\nTynn ships with [Tynn::Environment] to set and check the current environment for the application.\r\n\r\n```ruby\r\nrequire \"tynn\"\r\nrequire \"tynn/environment\"\r\n\r\nTynn.plugin(Tynn::Environment)\r\n```\r\n\r\nThe default environment is based on the `RACK_ENV` environment variable.\r\n\r\n```ruby\r\nENV[\"RACK_ENV\"]\r\n# => \"test\"\r\n\r\nTynn.environment\r\n# => :test\r\n```\r\n\r\nIf `ENV[\"RACK_ENV\"]` is `nil`, the default value is `:development`.\r\n\r\n```ruby\r\nTynn.environment\r\n# => :development\r\n```\r\n\r\nTo change the current environment, use the `environment=` method.\r\n\r\n```ruby\r\nTynn.environment = :development\r\n\r\nTynn.environment\r\n# => :development\r\n```\r\n\r\nTo check the current environment, use: `development?`, `test?`,\r\n`production?` or `staging?`.\r\n\r\n```ruby\r\nTynn.plugin(Tynn::Protection, ssl: Tynn.production?)\r\n```\r\n\r\nPerform operations on specific environments with the `configure` method.\r\n\r\n```ruby\r\nTynn.configure(:development) do |app|\r\n  app.use(Tynn::Static, %w(/js /css /images))\r\nend\r\n\r\nTynn.configure(:production) do |app|\r\n  app.use(Tynn::SSL)\r\nend\r\n```\r\n\r\n## Static Files\r\n\r\nTynn ships with [Tynn::Static] to serve static files such as images, CSS, JavaScript and others.\r\n\r\n```ruby\r\nrequire \"tynn\"\r\nrequire \"tynn/static\"\r\n\r\nTynn.plugin(Tynn::Static, %w(/js /css /images))\r\n```\r\n\r\nBy default, static files are served from the folder `public` in the current directory. You can specify a different location by passing the `:root` option:\r\n\r\n```ruby\r\nTynn.plugin(Tynn::Static, %w(/js /css /images), root: \"assets\")\r\n```\r\n\r\nAs you can see in the table below, the name of static directory is not included in the URL because the files are looked up relative to that directory.\r\n\r\n\r\n| File                         | URL                                    |\r\n| ---------------------------- | -------------------------------------- |\r\n| ./public/js/application.js   | http://example.org/js/application.js   |\r\n| ./public/css/application.css | http://example.org/css/application.css |\r\n| ./public/images/logo.png     | http://example.org/images/logo.png     |\r\n\r\nIt's important to mention that the path of the static directory path is relative to the directory where you run the application. If you run the application from another directory, it's safer to use an absolute path:\r\n\r\n```ruby\r\nTynn.plugin(\r\n  Tynn::Static,\r\n  %w(/js /css /images),\r\n  root: File.expand_path(\"public\", __dir__)\r\n)\r\n```\r\n\r\nTesting\r\n-------\r\n\r\nTynn ships with [Tynn::Test], a simple helper class to simulate requests to your application.\r\n\r\n```ruby\r\nrequire \"tynn\"\r\nrequire \"tynn/test\"\r\n\r\nTynn.define do\r\n  root do\r\n    res.write(\"hei\")\r\n  end\r\nend\r\n\r\napp = Tynn::Test.new\r\napp.get(\"/\")\r\n\r\n200   == app.res.status # => true\r\n\"hei\" == app.res.body   # => true\r\n```\r\n\r\n[Tynn::Test] is test-framework agnostic. The following example uses [Minitest]:\r\n\r\n```ruby\r\nrequire \"minitest/autorun\"\r\nrequire \"tynn/test\"\r\n\r\nclass GuestsRouteTest < Minitest::Test\r\n  def setup\r\n    @app = Tynn::Test.new\r\n  end\r\n\r\n  def test_home\r\n    @app.get(\"/\")\r\n\r\n    assert_equal 200, @app.res.status\r\n    assert_equal \"Hello World!\", @app.res.body\r\n    assert_equal \"text/html\", @app.res[\"Content-Type\"]\r\n  end\r\nend\r\n```\r\n\r\nIf this is not of your flavor, you can use any Rack-based testing library or framework, like: [Rack::Test] or [Capybara].\r\n\r\n## Changelog\r\n\r\nTo learn about new features, bug fixes, and changes, please refer to the [CHANGELOG](https://github.com/frodsan/tynn/blob/master/CHANGELOG.md).\r\n\r\n## Development\r\n\r\nFork the project with:\r\n\r\n```\r\n$ git clone git@github.com:frodsan/tynn.git\r\n```\r\n\r\nTo install dependencies, use:\r\n\r\n```\r\n$ bundle install\r\n```\r\n\r\nTo run the test suite, do:\r\n\r\n```\r\n$ rake test\r\n```\r\n\r\n## Contributing\r\n\r\nUse [GitHub Issues](https://github.com/frodsan/tynn/issues) for reporting bugs, discussing features and general feedback. If you've found a problem in Tynn, be sure to check the [past issues](https://github.com/frodsan/tynn/issues?state=closed) before open a new one.\r\n\r\n## Code Status\r\n\r\n[![Build Status](https://travis-ci.org/frodsan/tynn.svg?branch=master)](https://travis-ci.org/frodsan/tynn)\r\n\r\n[![Build History](https://buildstats.info/travisci/chart/frodsan/tynn?branch=master)](https://travis-ci.org/frodsan/tynn/builds)\r\n\r\n## License\r\n\r\nTynn is released under the [MIT License](http://www.opensource.org/licenses/MIT).\r\n\r\n[capybara]: https://github.com/jnicklas/capybara\r\n[minitest]: https://github.com/seattlerb/minitest\r\n[rack::test]: https://github.com/brynary/rack-test\r\n[tynn::environment]: http://api.tynn.xyz/Tynn/Environment.html\r\n[tynn::static]: http://api.tynn.xyz/Tynn/Static.html\r\n[tynn::test]: http://api.tynn.xyz/Tynn/Test.html\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}